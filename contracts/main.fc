#include "imports/stdlib.fc";

const const::min_tons_for_storage = 100000000; ;; 0.1 TON

;; A getter function that returns all the different values stored in the contract's c4 storage.
;; In this contract, there are 3 variables: 
;;  1. contract counter (int).
;;  2. address of the last sender (slice).
;;  3. address of the owner of the contract (slice). 
(int, slice, slice) load_data() inline {
    var ds = get_data().begin_parse();
    return (
        ds~load_uint(32), ;; counter_value
        ds~load_msg_addr(), ;; the most recent sender
        ds~load_msg_addr() ;; owner_address
    );
}

;; A setter function that sets all the different values stored in the contract's c4 storage.
;; Any time a new value needs to be stored, you need to re-set (set again) all the values that are stored in the contract c4 storage.
;; This is needed because whenever we are updating the storage, the current storage cell is getting thrown away,
;;   and a new cell is constructed and stored instead of the thrown-away cell. -###cells are immutable###-
() save_data(int counter_value, slice recent_sender, slice owner_address) impure inline {
    set_data(begin_cell()
    .store_uint(counter_value, 32) ;; counter_value : 32 bits (because it is an int32)
    .store_slice(recent_sender) ;; the most recent sender : a slice
    .store_slice(owner_address) ;; owner_address : a slice
    .end_cell());
}

() recv_internal(int msg_value, cell in_msg, slice in_msg_body) impure {
    slice cs = in_msg.begin_parse(); ;;Start parsing the in_msg cell
    int flags = cs~load_uint(4); ;;First 4 bits: flags. Example: ( 0011 <=(represented by)=> 3 | 0111 <=(represented by)=> 7 | 1100 <=(represented by)=> 12 | etc...)
    slice sender_address = cs~load_msg_addr(); ;;Next to the flags lies the sender of the message. It is an internal message, so it has been sent by a contract.
                                               ;; Note that the sender contract could be anything. A wallet, another dapp, etc...
    int op = in_msg_body~load_uint(32); ;;loading the op-code from the message body. op-code will tell the function what part to execute. 

    var (counter_value, recent_sender, owner_address) = load_data(); ;;loading the contract's c4 storage

    if (op == 1) {
        ;;counter_incrementor
        ;;assigning values to the ALL contract's storage cell variables. Even the unchanged values need to be set again.
        save_data(counter_value + 1, sender_address, owner_address); 
        return();
    }

    if (op == 2) {
        ;; deposit
        ;; This is pure deposit (could be used to top-up the contract's funds, for rent payment etc...)
        ;; No logic is needed here. Only a return(). This way, the message won't revert, and the funds will be recieved by the contract.
        return();
    }

    if (op == 3) {
        ;; withdrawal
        throw_unless(101, equal_slice_bits(sender_address, owner_address)); ;;checking whether the sender is the owner. OnlyOwner condition. error 101 if not met.

        int withdraw_amount = in_msg_body~load_coins(); ;;get the requested amount of withdrawal.
        var [balance, _] = get_balance(); ;;get the balance of the contract.
        throw_unless(102, balance >= withdraw_amount); ;;throw an error 102 if the amount 

        int return_value = min(withdraw_amount, balance - const::min_tons_for_storage);

        int msg_mode = 1; ;; 0 (Ordinary message) + 1 (Pay transfer fees separately from the message value)

        var msg = begin_cell()
            .store_uint(0x18, 6)
            .store_slice(sender_address)
            .store_coins(return_value)
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1);

        send_raw_message(msg.end_cell(), msg_mode);

        return();
    }

    throw(777); ;; an arbitrary number. It gets thrown when the sent op-code isn't handled in the contract.
                ;; This will bounce the message back
}

(int, slice, slice) get_contract_storage_data() method_id {
    var (counter_value, recent_sender, owner_address) = load_data(); ;; Using the function we defined above to load the contract's data.
    return (
        counter_value,
        recent_sender,
        owner_address
    ); ;; Returning the data.
}

int balance() method_id {
    var [balance, _] = get_balance();
    return balance;
}